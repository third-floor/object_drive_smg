<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Historic Rail Explorer ðŸš‚</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- MarkerCluster for performance -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Turf.js for geometry math -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: system-ui, sans-serif; }
    #map { position: absolute; top: 0; left: 320px; right: 0; bottom: 0; }
    #sidebar {
      position: absolute; top: 0; left: 0; bottom: 0; width: 320px;
      background: white; box-shadow: 2px 0 10px rgba(0,0,0,0.15);
      overflow-y: auto; padding: 10px; z-index: 1000;
    }
    #sidebar h2 { text-align: center; }
    .train-icon {
      width: 60px; height: 60px;
      background-image: url('https://cdn-icons-png.flaticon.com/512/757/757594.png');
      background-size: contain; background-repeat: no-repeat;
      transform-origin: center;
    }
    .direction-arrow {
      width: 20px; height: 20px;
      background: url('https://upload.wikimedia.org/wikipedia/commons/3/3c/Arrow_up_font_awesome.svg') no-repeat center;
      background-size: contain;
    }
    #controls {
      margin-top: 10px;
      padding: 8px;
      border-top: 1px solid #ccc;
      font-size: 0.9em;
    }
    #speedValue { font-weight: bold; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2>ðŸš‰ Nearby Objects</h2>
    <div id="info">Loading network...</div>
    <div id="controls">
      <label>Speed: <span id="speedValue">1.0</span>x</label><br>
      <input type="range" id="speedSlider" min="0.5" max="4" step="0.1" value="1.0" />
    </div>
  </div>
  <div id="map"></div>

  <script>
    const map = L.map('map').setView([53.5, -2.5], 10); // start zoomed in around northern England
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const trainIcon = L.divIcon({ className: 'train-icon' });
    const arrowIcon = L.divIcon({ className: 'direction-arrow' });
    let trainMarker = L.marker([53.5, -2.5], { icon: trainIcon }).addTo(map);
    let directionMarker = L.marker([53.5, -2.5], { icon: arrowIcon }).addTo(map);
    let trainPos = { lat: 53.5, lng: -2.5 };
    let stations = [], railways = [], currentStation = null;
    let objects = [];
    const sidebar = document.getElementById('info');

    let speedMultiplier = 1.0;
    document.getElementById('speedSlider').addEventListener('input', (e) => {
      speedMultiplier = parseFloat(e.target.value);
      document.getElementById('speedValue').textContent = speedMultiplier.toFixed(1);
    });

    // --- Load Data ---
    Promise.all([
      fetch('./data/railways_1881.geojson').then(r => r.json()),
      fetch('./data/stations_1881.geojson').then(r => r.json()),
      fetch('./objects.json').then(r => r.json())
    ]).then(([railData, stationData, objData]) => {
      objects = objData;

      // Railway lines (simplified)
      L.geoJSON(railData, { color: '#555', weight: 1.5 }).addTo(map);

      // Cluster stations for performance
      const stationCluster = L.markerClusterGroup({ chunkedLoading: true, spiderfyOnMaxZoom: false });
      stations = stationData.features.map(f => ({
        name: f.properties.name || "Station",
        lat: f.geometry.coordinates[1],
        lng: f.geometry.coordinates[0]
      }));
      stations.forEach(s => {
        const m = L.circleMarker([s.lat, s.lng], { radius: 4, color: 'red' });
        m.bindTooltip(s.name);
        stationCluster.addLayer(m);
      });
      map.addLayer(stationCluster);

      // Object markers
      const objGroup = L.layerGroup();
      objects.forEach(o => {
        if (o.lat && o.lng) {
          const marker = L.marker([o.lat, o.lng]).bindPopup(`<b>${o.title}</b><br><i>${o.category}</i><br>${o.place || ''}`);
          objGroup.addLayer(marker);
        }
      });
      map.addLayer(objGroup);

      railways = railData.features;

      sidebar.innerHTML = `Loaded ${stations.length} stations and ${objects.length} objects.<br><br>Use arrow keys to move train along network.`;

      const start = nearestStation(trainPos, stations);
      trainPos = { lat: start.lat, lng: start.lng };
      trainMarker.setLatLng(trainPos);
      directionMarker.setLatLng(trainPos);
      currentStation = start;
      map.panTo(trainPos);

      document.addEventListener('keydown', e => {
        if (["ArrowUp","w","W","ArrowDown","s","S","ArrowLeft","a","A","ArrowRight","d","D"].includes(e.key)) {
          moveTrain();
        }
      });
    });

    // --- Helpers ---
    function nearestStation(pos, list) {
      let min = Infinity, nearest = null;
      list.forEach(s => {
        const d = map.distance([pos.lat,pos.lng],[s.lat,s.lng]);
        if (d < min) { min = d; nearest = s; }
      });
      return nearest;
    }

    // --- Train movement ---
    let moving = false;
    function moveTrain() {
      if (moving) return;
      const next = findNearestConnectedStation(currentStation);
      if (!next) return;

      const path = findRailPath(currentStation, next);
      if (!path) return;

      const route = L.polyline(path, { color: 'blue', weight: 3 }).addTo(map);
      moving = true;
      animateTrain(path, next, route);
    }

    // Find a connected station along same line
    function findNearestConnectedStation(station) {
      const currentPoint = turf.point([station.lng, station.lat]);
      const candidates = [];
      railways.forEach(line => {
        const geom = turf.lineString(line.geometry.coordinates);
        const d = turf.pointToLineDistance(currentPoint, geom, { units: 'kilometers' });
        if (d < 0.2) {
          stations.forEach(s => {
            if (s.name !== station.name) {
              const sp = turf.point([s.lng, s.lat]);
              const d2 = turf.pointToLineDistance(sp, geom, { units: 'kilometers' });
              if (d2 < 0.2) candidates.push(s);
            }
          });
        }
      });
      if (candidates.length === 0) return null;
      return nearestStation(station, candidates);
    }

    // Find the rail path between two connected stations
    function findRailPath(a, b) {
      let best = null, bestDist = Infinity;
      railways.forEach(line => {
        const geom = turf.lineString(line.geometry.coordinates);
        const d1 = turf.pointToLineDistance(turf.point([a.lng, a.lat]), geom);
        const d2 = turf.pointToLineDistance(turf.point([b.lng, b.lat]), geom);
        if (d1 < 0.2 && d2 < 0.2 && d1 + d2 < bestDist) {
          bestDist = d1 + d2;
          best = line.geometry.coordinates.map(c => [c[1], c[0]]);
        }
      });
      return best;
    }

    // Animate along curved track with speed control
    function animateTrain(coords, nextStation, routeLine) {
      let i = 0;
      const total = coords.length;
      const step = Math.max(1, Math.floor(3 / speedMultiplier));

      const move = setInterval(() => {
        if (i >= total) {
          clearInterval(move);
          moving = false;
          trainPos = { lat: nextStation.lat, lng: nextStation.lng };
          trainMarker.setLatLng(trainPos);
          directionMarker.setLatLng(trainPos);
          map.removeLayer(routeLine);
          currentStation = nextStation;
          showNearbyObjects(nextStation);
          return;
        }
        const [lat, lng] = coords[i];
        const next = coords[Math.min(i + 5, total - 1)];
        const angle = bearing([lng, lat], [next[1], next[0]]);
        trainMarker.getElement()?.style.setProperty('transform', `rotate(${angle}deg)`);
        trainMarker.setLatLng([lat, lng]);
        directionMarker.setLatLng([lat, lng]);
        map.panTo([lat, lng]);
        i += step;
      }, 40 / speedMultiplier);
    }

    // Compute direction angle
    function bearing(a, b) {
      const [lon1, lat1] = a, [lon2, lat2] = b;
      const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) -
                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
      return Math.atan2(y, x) * 180 / Math.PI;
    }

    // Show nearby museum objects
    function showNearbyObjects(station) {
      const nearby = objects.filter(o => o.lat && o.lng && map.distance([station.lat, station.lng], [o.lat, o.lng]) < 24000);
      let html = `<h2>ðŸš‰ ${station.name}</h2><p>${nearby.length} objects within 15 miles:</p>`;
      nearby.slice(0, 25).forEach(o => {
        html += `<div style="margin-bottom:8px;"><b>${o.title}</b><br><i>${o.category}</i><br><small>${o.place || ''}</small></div>`;
      });
      sidebar.innerHTML = html;
    }
  </script>
</body>
</html>
