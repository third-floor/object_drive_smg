<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Historic Rail Explorer üöÜ</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<style>
html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui,sans-serif;}
#map{position:absolute;top:0;bottom:0;left:0;right:0;}
.train-emoji{font-size:48px;transform:translate(-50%,-50%);}
.hud{
  position:absolute;bottom:10px;left:50%;transform:translateX(-50%);
  background:rgba(255,255,255,0.95);border-radius:12px;
  box-shadow:0 2px 8px rgba(0,0,0,0.3);padding:8px 16px;z-index:1000;
}
#loading{
  display:none;position:absolute;top:0;left:0;width:100%;height:100%;
  background:rgba(255,255,255,0.9);z-index:2000;
  flex-direction:column;justify-content:center;align-items:center;font-size:1.5em;
}
#loading span{font-size:64px;margin-bottom:10px;}
.choice-btn{
  position:absolute;pointer-events:auto;background:orange;border:none;color:#fff;
  border-radius:8px;padding:6px 10px;cursor:pointer;transition:0.2s;
  font-size:0.9em;box-shadow:0 2px 6px rgba(0,0,0,0.3);z-index:1600;
}
.choice-btn:hover{background:darkorange;transform:scale(1.1);}
#fastTravelPanel{
  position:absolute;top:10px;left:50%;transform:translateX(-50%);
  background:rgba(255,255,255,0.95);padding:6px 12px;border-radius:8px;
  z-index:1200;display:flex;gap:6px;
}
#fastTravelPanel input{
  padding:6px;width:220px;border:1px solid #ccc;border-radius:6px;
}
#fastTravelPanel button{
  background:#0078d7;border:none;color:#fff;padding:6px 10px;
  border-radius:6px;cursor:pointer;
}
#fastTravelPanel button:hover{background:#005fa3;}
</style>
</head>
<body>
<div id="map"></div>

<div id="fastTravelPanel">
  <input type="text" id="stationSearch" placeholder="Fast travel to station..." />
  <button id="travelBtn">Go</button>
</div>

<div class="hud">üìç Station: <b id="stationDisplay">Loading...</b></div>
<div id="loading"><span>üöÜ</span><div>Travelling to next station...</div></div>

<script>
// === Map setup ===
const map=L.map('map',{keyboard:false}).setView([53.5,-2.5],8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
  attribution:'&copy; OpenStreetMap contributors'
}).addTo(map);

const trainIcon=L.divIcon({className:'',html:'<div class="train-emoji">üöÜ</div>',iconSize:[48,48],iconAnchor:[24,24]});
const trainMarker=L.marker([53.5,-2.5],{icon:trainIcon}).addTo(map);

const hudStation=document.getElementById('stationDisplay');
const loadingScreen=document.getElementById('loading');
let railways=[],stations=[],objects=[],objectMarkers=[],stationMarkers=[];
let currentStation=null,highlightLine=null,choiceButtons=[];

// === Load data ===
Promise.all([
  fetch('./data/railways_1881.geojson').then(r=>r.ok?r.json():[]),
  fetch('./wikidata_train_stations.json').then(r=>r.ok?r.json():[]),
  fetch('./objects.json').then(r=>r.ok?r.json():[])
]).then(([railData,stationData,objectData])=>{
  railways=(railData?.features||[]).filter(f=>f.geometry?.coordinates);
  stations=(stationData||[]).map(s=>({
    name:s.itemLabel,
    lat:parseFloat(s.lat),
    lng:parseFloat(s.lon)
  })).filter(s=>!isNaN(s.lat)&&!isNaN(s.lng));
  objects=(objectData||[]);

  // Draw layers
  if(railways.length)L.geoJSON(railways,{color:'#444',weight:2,opacity:0.8}).addTo(map);
  stations.forEach(s=>{
    const m=L.circleMarker([s.lat,s.lng],{radius:4,color:'#0044cc',fillColor:'#00aaff',fillOpacity:0.9})
      .bindTooltip(s.name).addTo(map);
    stationMarkers.push({station:s,marker:m});
  });
  objects.forEach(o=>{
    const m=L.circleMarker([o.lat,o.lng],{radius:5,color:'#aa0000',fillColor:'#ff5555',fillOpacity:0.7})
      .bindPopup(`<b>${o.title}</b><br>${o.description}<br><i>${o.place}</i>`).addTo(map);
    m.closePopup();objectMarkers.push(m);
  });

  const start=nearestStation({lat:53.5,lng:-2.5});
  arriveAtStation(start);
}).catch(e=>console.error("Data load error:",e));

// === Utility ===
function nearestStation(pos){
  let nearest=null,min=Infinity;
  for(const s of stations){
    const d=map.distance([pos.lat,pos.lng],[s.lat,s.lng]);
    if(d<min){min=d;nearest=s;}
  }
  return nearest||stations[0];
}

// Merge lines by proximity without infinite recursion
function expandConnectedLines(line){
  const connected=new Set([line]);
  const maxDepth=500;
  let changed=true,depth=0;
  while(changed && depth<maxDepth){
    changed=false;depth++;
    for(const other of railways){
      if(connected.has(other))continue;
      if(linesClose(connected,other)){
        connected.add(other);changed=true;
      }
    }
  }
  return Array.from(connected);
}
function linesClose(lines,candidate){
  const tol=300; // meters
  for(const line of lines){
    const a=line.geometry.coordinates,b=candidate.geometry.coordinates;
    if(!a||!b)continue;
    for(let i=0;i<a.length;i+=Math.max(1,Math.floor(a.length/10))){
      for(let j=0;j<b.length;j+=Math.max(1,Math.floor(b.length/10))){
        const d=map.distance([a[i][1],a[i][0]],[b[j][1],b[j][0]]);
        if(d<tol)return true;
      }
    }
  }
  return false;
}

// Find connected stations along merged lines
function connectedStations(station){
  const connected=new Set();
  const tolerance=1500;
  const pt=turf.point([station.lng,station.lat]);
  for(const line of railways){
    const geom=turf.lineString(line.geometry.coordinates);
    const snap1=turf.nearestPointOnLine(geom,pt);
    if(snap1.properties.dist*1000<tolerance){
      const network=expandConnectedLines(line);
      const coords=network.flatMap(f=>f.geometry.coordinates||[]);
      const big=turf.lineString(coords);
      const projections=stations.map(s2=>{
        const p2=turf.point([s2.lng,s2.lat]);
        const snap2=turf.nearestPointOnLine(big,p2);
        return {s2,dist:snap2.properties.dist*1000,loc:snap2.properties.location};
      }).filter(p=>p.dist<tolerance).sort((a,b)=>a.loc-b.loc);
      const idx=projections.findIndex(p=>p.s2===station);
      if(idx!==-1){
        if(projections[idx-1])connected.add(projections[idx-1].s2);
        if(projections[idx+1])connected.add(projections[idx+1].s2);
      }
    }
  }
  return Array.from(connected);
}

// === Gameplay ===
function revealNearbyObjects(station){
  const mile=1609.34;
  objectMarkers.forEach((m,i)=>{
    const o=objects[i];if(!o)return;
    const d=map.distance([station.lat,station.lng],[o.lat,o.lng]);
    if(d<10*mile)m.openPopup();else m.closePopup();
  });
}
function updateVisibleStations(center){
  const mile=1609.34;
  stationMarkers.forEach(({station,marker})=>{
    const d=map.distance([center.lat,center.lng],[station.lat,station.lng]);
    if(d<40*mile)marker.addTo(map);else map.removeLayer(marker);
  });
}
function arriveAtStation(station){
  if(!station)return;
  currentStation=station;
  hudStation.textContent=station.name;
  trainMarker.setLatLng([station.lat,station.lng]);
  map.setView([station.lat,station.lng],14);
  revealNearbyObjects(station);
  updateVisibleStations(station);
  showChoices(station);
}
function travelToStation(next){
  loadingScreen.style.display='flex';
  choiceButtons.forEach(b=>b.btn.remove());
  choiceButtons=[];
  if(highlightLine)map.removeLayer(highlightLine);
  highlightLine=L.polyline([[currentStation.lat,currentStation.lng],[next.lat,next.lng]],{
    color:'orange',weight:4,opacity:0.8
  }).addTo(map);
  setTimeout(()=>{
    loadingScreen.style.display='none';
    if(highlightLine)map.removeLayer(highlightLine);
    arriveAtStation(next);
  },1500);
}

// === Choice buttons ===
function showChoices(station){
  choiceButtons.forEach(b=>b.btn.remove());
  choiceButtons=[];
  const connected=connectedStations(station);
  if(!connected.length)return;
  stationMarkers.forEach(({station:s,marker})=>
    marker.setStyle({color:'#0044cc',fillColor:'#00aaff'}));
  connected.forEach(dest=>{
    const sm=stationMarkers.find(x=>x.station===dest);
    if(sm)sm.marker.setStyle({color:'orange',fillColor:'orange'});
  });
  connected.forEach(dest=>{
    const latlng=L.latLng(dest.lat,dest.lng);
    const btn=document.createElement('button');
    btn.className='choice-btn';
    btn.textContent=dest.name;
    btn.onclick=()=>travelToStation(dest);
    document.body.appendChild(btn);
    choiceButtons.push({btn,latlng});
  });
  repositionButtons();
}
function repositionButtons(){
  choiceButtons.forEach(({btn,latlng})=>{
    const pt=map.latLngToContainerPoint(latlng);
    btn.style.left=(pt.x-60)+'px';
    btn.style.top=(pt.y-25)+'px';
  });
}
map.on('zoom move',repositionButtons);

// === Fast travel ===
document.getElementById('travelBtn').onclick=()=>{
  const q=document.getElementById('stationSearch').value.toLowerCase();
  if(!q)return;
  const match=stations.find(s=>s.name.toLowerCase().includes(q));
  if(match)travelToStation(match);else alert("Station not found.");
};
</script>
</body>
</html>
